name: Test and Build Backend API

on:
  push:
    branches: 
      - dev
      - test
      - main
    paths:
      - 'backend/**'
      - '!backend/terraform/**'
      - '!backend/aws-setup/**'
      - '.github/workflows/ci-cd-test-build-backend.yml'
  pull_request:
    branches:
      - test  # PR from dev to test
      - main  # PR from test to main
    paths:
      - 'backend/**'
      - '!backend/terraform/**'
      - '!backend/aws-setup/**'
      - '.github/workflows/ci-cd-test-build-backend.yml'
  workflow_dispatch:  # Manual trigger
env:
  TF_STATE_BUCKET: ai-wizard-terraform-state-${{ vars.TF_VAR_AWS_REGION }}
  WORKING_DIRECTORY: backend
  ENVIRONMENT: ${{ github.event_name == 'pull_request' && (github.base_ref == 'main' && 'prod' || github.base_ref) || (github.ref_name == 'main' && 'prod' || github.ref_name) }}
  DOMAIN_NAME: ${{ github.event_name == 'pull_request' && (github.base_ref == 'main' && vars.TF_VAR_DOMAIN_NAME || format('{0}.{1}', github.base_ref, vars.TF_VAR_DOMAIN_NAME)) || (github.ref_name == 'main' && vars.TF_VAR_DOMAIN_NAME || format('{0}.{1}', github.ref_name, vars.TF_VAR_DOMAIN_NAME)) }}

jobs:
  should_run:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'pull_request' && github.event.action != 'closed') ||
      (github.event_name == 'push' && (
        github.ref == 'refs/heads/dev' ||
        github.ref == 'refs/heads/test' ||
        github.ref == 'refs/heads/main'
      ))
    outputs:
      run_deployment: ${{ steps.check.outputs.run }}
      is_deployable: ${{ steps.check.outputs.deployable }}
    steps:
      - uses: actions/checkout@v4
      - id: check
        run: |
          # Always run for workflow_dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "run=true" >> $GITHUB_OUTPUT
            echo "deployable=true" >> $GITHUB_OUTPUT
          # For PRs, run but don't deploy
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "run=true" >> $GITHUB_OUTPUT
            echo "deployable=false" >> $GITHUB_OUTPUT
          # For pushes to main branches, run and deploy
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            echo "run=true" >> $GITHUB_OUTPUT
            echo "deployable=true" >> $GITHUB_OUTPUT
          else
            echo "run=false" >> $GITHUB_OUTPUT
            echo "deployable=false" >> $GITHUB_OUTPUT
          fi

  test:
    needs: should_run
    if: needs.should_run.outputs.run_deployment == 'true'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      id: checkout_repo

    - name: Set up Python
      id: setup_python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Install Poetry
      run: |
        curl -sSL https://install.python-poetry.org | python3 -
        echo "$HOME/.local/bin" >> $GITHUB_PATH

    - name: Install dependencies
      id: install_dependencies
      run: |
        poetry install
        # Add PyYAML explicitly for OpenAPI spec generation
        poetry add PyYAML
      working-directory: ${{ env.WORKING_DIRECTORY }}

    - name: Set up environment
      id: setup_environment
      run: |
        # Create test environment file .env.test
        cat > .env.test << EOL
        DATABASE_URL=sqlite:///:memory:
        SECRET_KEY=dummy_secret_key_for_testing
        OPENAI_API_KEY=dummy-api-key-for-testing
        OPENAI_MODEL=gpt-4-turbo-preview
        ALLOWED_ORIGINS=https://${{ env.DOMAIN_NAME }},https://api.${{ env.DOMAIN_NAME }}
        EOL
        
        # Create Firebase config directory and use actual Firebase config from secrets
        mkdir -p app/config
        echo '${{ secrets.FIREBASE_ADMINSDK_JSON }}' > app/config/firebase-adminsdk.json

        # Create directories for OpenAPI specs
        mkdir -p app/openapi
        mkdir -p terraform/api

      working-directory: ${{ env.WORKING_DIRECTORY }}

    - name: Generate OpenAPI Specification
      id: generate_openapi
      env:
        PYTHONPATH: ${{ env.WORKING_DIRECTORY }}
        FIREBASE_CREDENTIALS: ${{ secrets.FIREBASE_ADMINSDK_JSON }}
      run: |
        # Generate OpenAPI spec
        poetry run python -c "
        from app.main import app
        import yaml
        from pathlib import Path
        
        # Generate spec with compatible version
        spec = app.openapi()
        spec['openapi'] = '3.0.2'  # Ensure API Gateway compatibility
        
        # Save in app directory
        app_spec_dir = Path('app/openapi')
        app_spec_dir.mkdir(exist_ok=True)
        with open(app_spec_dir / 'specification.yaml', 'w') as f:
            yaml.dump(spec, f, sort_keys=False)
            
        # Save in terraform directory
        terraform_spec_dir = Path('terraform/api')
        terraform_spec_dir.mkdir(exist_ok=True, parents=True)
        with open(terraform_spec_dir / 'specification.yaml', 'w') as f:
            yaml.dump(spec, f, sort_keys=False)
            
        # Validate specs exist and version
        assert Path('app/openapi/specification.yaml').exists(), 'App spec not generated'
        assert Path('terraform/api/specification.yaml').exists(), 'Terraform spec not generated'
        
        # Verify OpenAPI version
        with open(app_spec_dir / 'specification.yaml') as f:
            loaded_spec = yaml.safe_load(f)
            assert loaded_spec['openapi'] == '3.0.2', 'Invalid OpenAPI version'
        "
      working-directory: ${{ env.WORKING_DIRECTORY }}

    - name: Run tests
      id: run_tests
      env:
        PYTHONPATH: ${{ env.WORKING_DIRECTORY }}
        DATABASE_URL: "sqlite:///:memory:"
        SECRET_KEY: dummy_secret_key_for_testing
        OPENAI_API_KEY: dummy-api-key-for-testing
        OPENAI_MODEL: gpt-4-turbo-preview
        ALLOWED_ORIGINS: "https://${{ env.DOMAIN_NAME }},https://api.${{ env.DOMAIN_NAME }}"
      run: |
        # Run tests
        poetry run pytest \
          --cov=app \
          --cov-report=xml \
          --cov-report=term-missing \
          tests/
      working-directory: ${{ env.WORKING_DIRECTORY }}

    - name: Upload coverage data to coveralls.io
      id: upload_coverage
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        poetry run pip install coveralls
        poetry run coveralls --service=github
      working-directory: ${{ env.WORKING_DIRECTORY }}

  build:
    needs: [should_run, test]
    if: needs.should_run.outputs.run_deployment == 'true'
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repo
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Install Poetry
      run: |
        curl -sSL https://install.python-poetry.org | python3 -
        echo "$HOME/.local/bin" >> $GITHUB_PATH

    - name: Install dependencies and export requirements
      working-directory: ${{ env.WORKING_DIRECTORY }}
      run: |
        poetry install
        poetry export -f requirements.txt --output requirements.txt --without-hashes

        # Create Firebase config directory and file
        mkdir -p app/config
        if [ ! -e "app/config/firebase-adminsdk.json" ]; then
          echo "Creating Firebase config file 'app/config/firebase-adminsdk.json' ..."
          echo -n '${{ secrets.FIREBASE_ADMINSDK_JSON }}' > app/config/firebase-adminsdk.json
        fi
        
    - name: Package Lambda function
      working-directory: ${{ env.WORKING_DIRECTORY }}
      run: |
        # Create a temporary build directory
        mkdir -p build
        
        # Copy application code
        cp -r app build/
        
        # Create requirements file excluding development dependencies
        poetry export --only main -f requirements.txt --without-hashes --output requirements.txt
        
        # Install dependencies
        pip install \
          --target=build \
          --implementation cp \
          --python-version 3.12 \
          --only-binary=:all: \
          --platform manylinux2014_x86_64 \
          --upgrade pydantic \
          -r requirements.txt
        
        # Remove unnecessary files to reduce package size
        cd build
                
        # Clean up
        find . -type d -name "tests" -exec rm -rf {} +
        find . -type d -name "__pycache__" -exec rm -rf {} +
        find . -type f -name "*.pyc" -delete
        find . -type f -name "*.pyo" -delete
        find . -type f -name "*.pyd" -delete
        # Preserve email-validator dist-info while cleaning others
        find . -type d -name "*.dist-info" ! -name "email_validator*.dist-info" -exec rm -rf {} +
        find . -type d -name "*.egg-info" -exec rm -rf {} +
        
        # Create deployment package
        zip -r9 ../lambda_package.zip .
        cd ..
        
        # Create lambda directory if it doesn't exist
        mkdir -p terraform/lambda
        
        # Move package to terraform lambda directory
        mv lambda_package.zip terraform/lambda/
        
        # Show package size and contents
        ls -lh terraform/lambda/lambda_package.zip
        echo "Lambda package contents:"
        unzip -l terraform/lambda/lambda_package.zip | grep -i "email_validator"

    - name: Calculate Lambda package hash
      id: lambda_package_hash
      working-directory: ${{ env.WORKING_DIRECTORY }}
      run: |
        HASH=$(openssl dgst -sha256 -binary terraform/lambda/lambda_package.zip | openssl base64)
        echo "lambda_package_hash=${HASH}" >> $GITHUB_OUTPUT

    - name: Upload Lambda package
      uses: actions/upload-artifact@v4
      with:
        name: lambda_app_package
        path: ${{ env.WORKING_DIRECTORY }}/terraform/lambda/lambda_package.zip

  deploy:
    needs: [should_run, test, build]
    if: |
      needs.should_run.outputs.run_deployment == 'true' &&
      needs.should_run.outputs.is_deployable == 'true'
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.TF_VAR_AWS_REGION }}
        role-to-assume: arn:aws:iam::${{ vars.TF_VAR_AWS_ACCOUNT_ID }}:role/AIWizardDeploymentRole
        mask-aws-account-id: 'false'

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.0.0

    - name: Terraform Init
      id: terraform_init
      run: |
        terraform init \
          -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" \
          -backend-config="key=terraform.tfstate-${{ env.ENVIRONMENT }}" \
          -backend-config="region=${{ vars.TF_VAR_AWS_REGION }}" \
          -reconfigure
      working-directory: ${{ env.WORKING_DIRECTORY }}/terraform

    - name: Download Lambda package
      uses: actions/download-artifact@v4
      with:
        name: lambda_app_package
        path: ${{ env.WORKING_DIRECTORY }}/terraform/lambda/

    - name: Show Lambda package files
      working-directory: ${{ env.WORKING_DIRECTORY }}
      run: |
        ls -lh terraform/lambda/

    - name: Calculate Lambda package hash
      id: lambda_package_hash
      run: |
        HASH=$(openssl dgst -sha256 -binary terraform/lambda/lambda_package.zip | openssl base64)
        echo "lambda_package_hash=${HASH}" >> $GITHUB_OUTPUT
      working-directory: ${{ env.WORKING_DIRECTORY }}

    - name: Terraform Plan
      id: terraform_plan
      run: |
        terraform plan \
          -target=aws_lambda_function.api_v2 \
          -target=aws_lambda_alias.api_alias_v2 \
          -target=aws_apigatewayv2_integration.lambda \
          -target=aws_apigatewayv2_domain_name.api \
          -target=aws_apigatewayv2_stage.lambda \
          -target=aws_iam_service_linked_role.apigw \
          -var="aws_account_id=${{ vars.TF_VAR_AWS_ACCOUNT_ID }}" \
          -var="aws_region=${{ vars.TF_VAR_AWS_REGION }}" \
          -var="domain_name=${{ env.DOMAIN_NAME }}" \
          -var="route53_hosted_zone_id=${{ vars.TF_VAR_ROUTE53_HOSTED_ZONE_ID }}" \
          -var="frontend_bucket_name=${{ vars.TF_VAR_FRONTEND_BUCKET_NAME }}" \
          -var="lambda_function_name_prefix=${{ vars.TF_VAR_LAMBDA_FUNCTION_NAME_PREFIX }}" \
          -var="dynamodb_table_name=${{ vars.TF_VAR_DYNAMODB_TABLE_NAME }}" \
          -var="database_url=${{ vars.PROD_DATABASE_URL }}" \
          -var="environment=${{ env.ENVIRONMENT }}" \
          -var="lambda_source_code_hash=${{ steps.lambda_package_hash.outputs.lambda_package_hash }}" \
          -out=tfplan-${{ env.ENVIRONMENT }}
      working-directory: ${{ env.WORKING_DIRECTORY }}/terraform

    - name: Terraform Apply
      id: terraform_apply
      run: |
        terraform apply -auto-approve tfplan-${{ env.ENVIRONMENT }}
      working-directory: ${{ env.WORKING_DIRECTORY }}/terraform

    outputs:
      lambda_function_name: ${{ steps.terraform_apply.outputs.lambda_function_name }}

  notify_build:
    needs: [should_run, test, build]
    if: always() && needs.should_run.outputs.run_deployment == 'false'
    runs-on: ubuntu-latest
    steps:
    - name: Check job status
      id: check
      run: |
        if [[ ${{ needs.test.result }} == 'success' && ${{ needs.build.result }} == 'success' ]]; then
          echo "status=success" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
        fi

    - name: Notify Slack
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ steps.check.outputs.status }}
        text: |
          ${{ steps.check.outputs.status == 'success' && format('{0} Test and Build succeeded! :rocket:', env.ENVIRONMENT) || format('{0} Test or Build failed! :x:', env.ENVIRONMENT) }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}    

  notify_deployment:
    needs: [should_run, test, build, deploy]
    if: always() && needs.should_run.outputs.run_deployment == 'true'
    runs-on: ubuntu-latest
    steps:
    - name: Check job status
      id: check
      run: |
        if [[ ${{ needs.test.result }} == 'success' && ${{ needs.build.result }} == 'success' && ${{ needs.deploy.result }} == 'success' ]]; then
          echo "status=success" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
        fi

    - name: Notify Slack
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ steps.check.outputs.status }}
        text: |
          ${{ steps.check.outputs.status == 'success' && format('{0} Test and Build succeeded! :rocket:', env.ENVIRONMENT) || format('{0} Test or Build failed! :x:', env.ENVIRONMENT) }}
          ${{ steps.check.outputs.status == 'success' && format('Lambda function for {0} stage deployed to: {1}', env.ENVIRONMENT, needs.deploy.outputs.lambda_function_name) || '' }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

